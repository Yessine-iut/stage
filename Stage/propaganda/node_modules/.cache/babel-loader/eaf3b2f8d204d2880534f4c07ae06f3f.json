{"ast":null,"code":"/**\n * @ignore\n * css3 selector engine for ie6-8\n * @author yiminghe@gmail.com\n */\nvar util = require('./query-selector/util');\n\nvar parser = require('./query-selector/parser');\n\nvar EXPANDO_SELECTOR_KEY = '_ks_data_selector_id_',\n    caches = {},\n    isContextXML,\n    uuid = 0,\n    subMatchesCache = {},\n    getAttr = function (el, name) {\n  if (isContextXML) {\n    return util.getSimpleAttr(el, name);\n  } else {\n    return util.attr(el, name);\n  }\n},\n    hasSingleClass = util.hasSingleClass,\n    isTag = util.isTag,\n    aNPlusB = /^(([+-]?(?:\\d+)?)?n)?([+-]?\\d+)?$/; // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\n\nvar unescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n    unescapeFn = function (_, escaped) {\n  var high = '0x' + escaped - 0x10000; // NaN means non-codepoint\n\n  return isNaN(high) ? escaped : // BMP codepoint\n  high < 0 ? String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n};\n\nvar matchExpr;\nvar pseudoFnExpr = {\n  'nth-child': function (el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          count = 0,\n          child,\n          ret,\n          len = childNodes.length;\n\n      for (; count < len; count++) {\n        child = childNodes[count];\n\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-last-child': function (el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          len = childNodes.length,\n          count = len - 1,\n          child,\n          ret;\n\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-of-type': function (el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          elType = el.tagName,\n          count = 0,\n          child,\n          ret,\n          len = childNodes.length;\n\n      for (; count < len; count++) {\n        child = childNodes[count];\n\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-last-of-type': function (el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          len = childNodes.length,\n          elType = el.tagName,\n          count = len - 1,\n          child,\n          ret;\n\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  lang: function (el, lang) {\n    var elLang;\n    lang = unEscape(lang.toLowerCase());\n\n    do {\n      if (elLang = isContextXML ? el.getAttribute('xml:lang') || el.getAttribute('lang') : el.lang) {\n        elLang = elLang.toLowerCase();\n        return elLang === lang || elLang.indexOf(lang + '-') === 0;\n      }\n    } while ((el = el.parentNode) && el.nodeType === 1);\n\n    return false;\n  },\n  not: function (el, negationArg) {\n    return !matchExpr[negationArg.t](el, negationArg.value);\n  }\n};\nvar pseudoIdentExpr = {\n  empty: function (el) {\n    var childNodes = el.childNodes,\n        index = 0,\n        len = childNodes.length - 1,\n        child,\n        nodeType;\n\n    for (; index < len; index++) {\n      child = childNodes[index];\n      nodeType = child.nodeType; // only element nodes and content nodes\n      // (such as Dom [Dom-LEVEL-3-CORE] text nodes,\n      // CDATA nodes, and entity references\n\n      if (nodeType === 1 || nodeType === 3 || nodeType === 4 || nodeType === 5) {\n        return 0;\n      }\n    }\n\n    return 1;\n  },\n  root: function (el) {\n    if (el.nodeType === 9) {\n      return true;\n    }\n\n    return el.ownerDocument && el === el.ownerDocument.documentElement;\n  },\n  'first-child': function (el) {\n    return pseudoFnExpr['nth-child'](el, 1);\n  },\n  'last-child': function (el) {\n    return pseudoFnExpr['nth-last-child'](el, 1);\n  },\n  'first-of-type': function (el) {\n    return pseudoFnExpr['nth-of-type'](el, 1);\n  },\n  'last-of-type': function (el) {\n    return pseudoFnExpr['nth-last-of-type'](el, 1);\n  },\n  'only-child': function (el) {\n    return pseudoIdentExpr['first-child'](el) && pseudoIdentExpr['last-child'](el);\n  },\n  'only-of-type': function (el) {\n    return pseudoIdentExpr['first-of-type'](el) && pseudoIdentExpr['last-of-type'](el);\n  },\n  focus: function (el) {\n    var doc = el.ownerDocument;\n    return doc && el === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(el.type || el.href || el.tabIndex >= 0);\n  },\n  target: function (el) {\n    var hash = location.hash;\n    return hash && hash.slice(1) === getAttr(el, 'id');\n  },\n  enabled: function (el) {\n    return !el.disabled;\n  },\n  disabled: function (el) {\n    return el.disabled;\n  },\n  checked: function (el) {\n    var nodeName = el.nodeName.toLowerCase();\n    return nodeName === 'input' && el.checked || nodeName === 'option' && el.selected;\n  }\n};\nvar attributeExpr = {\n  '~=': function (elValue, value) {\n    if (!value || value.indexOf(' ') > -1) {\n      return 0;\n    }\n\n    return (' ' + elValue + ' ').indexOf(' ' + value + ' ') !== -1;\n  },\n  '|=': function (elValue, value) {\n    return (' ' + elValue).indexOf(' ' + value + '-') !== -1;\n  },\n  '^=': function (elValue, value) {\n    return value && util.startsWith(elValue, value);\n  },\n  '$=': function (elValue, value) {\n    return value && util.endsWith(elValue, value);\n  },\n  '*=': function (elValue, value) {\n    return value && elValue.indexOf(value) !== -1;\n  },\n  '=': function (elValue, value) {\n    return elValue === value;\n  }\n};\nvar relativeExpr = {\n  '>': {\n    dir: 'parentNode',\n    immediate: 1\n  },\n  ' ': {\n    dir: 'parentNode'\n  },\n  '+': {\n    dir: 'previousSibling',\n    immediate: 1\n  },\n  '~': {\n    dir: 'previousSibling'\n  }\n};\nmatchExpr = {\n  tag: isTag,\n  cls: hasSingleClass,\n  id: function (el, value) {\n    return getAttr(el, 'id') === value;\n  },\n  attrib: function (el, value) {\n    var name = value.ident;\n\n    if (!isContextXML) {\n      name = name.toLowerCase();\n    }\n\n    var elValue = getAttr(el, name);\n    var match = value.match;\n\n    if (!match && elValue !== undefined) {\n      return 1;\n    } else if (match) {\n      if (elValue === undefined) {\n        return 0;\n      }\n\n      var matchFn = attributeExpr[match];\n\n      if (matchFn) {\n        return matchFn(elValue + '', value.value + '');\n      }\n    }\n\n    return 0;\n  },\n  pseudo: function (el, value) {\n    var fn, fnStr, ident;\n\n    if (fnStr = value.fn) {\n      if (!(fn = pseudoFnExpr[fnStr])) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + fnStr);\n      }\n\n      return fn(el, value.param);\n    }\n\n    if (ident = value.ident) {\n      if (!pseudoIdentExpr[ident]) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + ident);\n      }\n\n      return pseudoIdentExpr[ident](el);\n    }\n\n    return 0;\n  }\n};\n\nfunction unEscape(str) {\n  return str.replace(unescape, unescapeFn);\n}\n\nparser.lexer.yy = {\n  trim: util.trim,\n  unEscape: unEscape,\n  unEscapeStr: function (str) {\n    return this.unEscape(str.slice(1, -1));\n  }\n};\n\nfunction resetStatus() {\n  subMatchesCache = {};\n}\n\nfunction dir(el, direction) {\n  do {\n    el = el[direction];\n  } while (el && el.nodeType !== 1);\n\n  return el;\n}\n\nfunction getAb(param) {\n  var a = 0,\n      match,\n      b = 0;\n\n  if (typeof param === 'number') {\n    b = param;\n  } else if (param === 'odd') {\n    a = 2;\n    b = 1;\n  } else if (param === 'even') {\n    a = 2;\n    b = 0;\n  } else if (match = param.replace(/\\s/g, '').match(aNPlusB)) {\n    if (match[1]) {\n      a = parseInt(match[2], 10);\n\n      if (isNaN(a)) {\n        if (match[2] === '-') {\n          a = -1;\n        } else {\n          a = 1;\n        }\n      }\n    } else {\n      a = 0;\n    }\n\n    b = parseInt(match[3], 10) || 0;\n  }\n\n  return {\n    a: a,\n    b: b\n  };\n}\n\nfunction matchIndexByAb(index, a, b, eq) {\n  if (a === 0) {\n    if (index === b) {\n      return eq;\n    }\n  } else {\n    if ((index - b) / a >= 0 && (index - b) % a === 0 && eq) {\n      return 1;\n    }\n  }\n\n  return undefined;\n}\n\nfunction isXML(elem) {\n  var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n  return documentElement ? documentElement.nodeName.toLowerCase() !== 'html' : false;\n}\n\nfunction matches(str, seeds) {\n  return select(str, null, seeds);\n}\n\nfunction singleMatch(el, match) {\n  if (!match) {\n    return true;\n  }\n\n  if (!el) {\n    return false;\n  }\n\n  if (el.nodeType === 9) {\n    return false;\n  }\n\n  var matched = 1,\n      matchSuffix = match.suffix,\n      matchSuffixLen,\n      matchSuffixIndex;\n\n  if (match.t === 'tag') {\n    matched &= matchExpr.tag(el, match.value);\n  }\n\n  if (matched && matchSuffix) {\n    matchSuffixLen = matchSuffix.length;\n    matchSuffixIndex = 0;\n\n    for (; matched && matchSuffixIndex < matchSuffixLen; matchSuffixIndex++) {\n      var singleMatchSuffix = matchSuffix[matchSuffixIndex],\n          singleMatchSuffixType = singleMatchSuffix.t;\n\n      if (matchExpr[singleMatchSuffixType]) {\n        matched &= matchExpr[singleMatchSuffixType](el, singleMatchSuffix.value);\n      }\n    }\n  }\n\n  return matched;\n} // match by adjacent immediate single selector match\n\n\nfunction matchImmediate(el, match) {\n  var matched = 1,\n      startEl = el,\n      relativeOp,\n      startMatch = match;\n\n  do {\n    matched &= singleMatch(el, match);\n\n    if (matched) {\n      // advance\n      match = match && match.prev;\n\n      if (!match) {\n        return true;\n      }\n\n      relativeOp = relativeExpr[match.nextCombinator];\n      el = dir(el, relativeOp.dir);\n\n      if (!relativeOp.immediate) {\n        return {\n          // advance for non-immediate\n          el: el,\n          match: match\n        };\n      }\n    } else {\n      relativeOp = relativeExpr[match.nextCombinator];\n\n      if (relativeOp.immediate) {\n        // retreat but advance startEl\n        return {\n          el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n          match: startMatch\n        };\n      } else {\n        // advance (before immediate match + jump unmatched)\n        return {\n          el: el && dir(el, relativeOp.dir),\n          match: match\n        };\n      }\n    }\n  } while (el); // only occur when match immediate\n\n\n  return {\n    el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n    match: startMatch\n  };\n} // find fixed part, fixed with seeds\n\n\nfunction findFixedMatchFromHead(el, head) {\n  var relativeOp,\n      cur = head;\n\n  do {\n    if (!singleMatch(el, cur)) {\n      return null;\n    }\n\n    cur = cur.prev;\n\n    if (!cur) {\n      return true;\n    }\n\n    relativeOp = relativeExpr[cur.nextCombinator];\n    el = dir(el, relativeOp.dir);\n  } while (el && relativeOp.immediate);\n\n  if (!el) {\n    return null;\n  }\n\n  return {\n    el: el,\n    match: cur\n  };\n}\n\nfunction genId(el) {\n  var selectorId;\n\n  if (isContextXML) {\n    if (!(selectorId = el.getAttribute(EXPANDO_SELECTOR_KEY))) {\n      el.setAttribute(EXPANDO_SELECTOR_KEY, selectorId = +new Date() + '_' + ++uuid);\n    }\n  } else {\n    if (!(selectorId = el[EXPANDO_SELECTOR_KEY])) {\n      selectorId = el[EXPANDO_SELECTOR_KEY] = +new Date() + '_' + ++uuid;\n    }\n  }\n\n  return selectorId;\n}\n\nfunction matchSub(el, match) {\n  var selectorId = genId(el),\n      matchKey;\n  matchKey = selectorId + '_' + (match.order || 0);\n\n  if (matchKey in subMatchesCache) {\n    return subMatchesCache[matchKey];\n  }\n\n  subMatchesCache[matchKey] = matchSubInternal(el, match);\n  return subMatchesCache[matchKey];\n} // recursive match by sub selector string from right to left\n// grouped by immediate selectors\n\n\nfunction matchSubInternal(el, match) {\n  var matchImmediateRet = matchImmediate(el, match);\n\n  if (matchImmediateRet === true) {\n    return true;\n  } else {\n    el = matchImmediateRet.el;\n    match = matchImmediateRet.match;\n\n    while (el) {\n      if (matchSub(el, match)) {\n        return true;\n      }\n\n      el = dir(el, relativeExpr[match.nextCombinator].dir);\n    }\n\n    return false;\n  }\n}\n\nfunction select(str, context, seeds) {\n  if (!caches[str]) {\n    caches[str] = parser.parse(str);\n  }\n\n  var selector = caches[str],\n      groupIndex = 0,\n      groupLen = selector.length,\n      contextDocument,\n      group,\n      ret = [];\n\n  if (seeds) {\n    context = context || seeds[0].ownerDocument;\n  }\n\n  contextDocument = context && context.ownerDocument || typeof document !== 'undefined' && document;\n\n  if (context && context.nodeType === 9 && !contextDocument) {\n    contextDocument = context;\n  }\n\n  context = context || contextDocument;\n  isContextXML = isXML(context);\n\n  for (; groupIndex < groupLen; groupIndex++) {\n    resetStatus();\n    group = selector[groupIndex];\n    var suffix = group.suffix,\n        suffixIndex,\n        suffixLen,\n        seedsIndex,\n        mySeeds = seeds,\n        seedsLen,\n        id = null;\n\n    if (!mySeeds) {\n      if (suffix && !isContextXML) {\n        suffixIndex = 0;\n        suffixLen = suffix.length;\n\n        for (; suffixIndex < suffixLen; suffixIndex++) {\n          var singleSuffix = suffix[suffixIndex];\n\n          if (singleSuffix.t === 'id') {\n            id = singleSuffix.value;\n            break;\n          }\n        }\n      }\n\n      if (id) {\n        // http://yiminghe.github.io/lab/playground/fragment-selector/selector.html\n        var doesNotHasById = !context.getElementById,\n            contextInDom = util.contains(contextDocument, context),\n            tmp = doesNotHasById ? contextInDom ? contextDocument.getElementById(id) : null : context.getElementById(id); // id bug\n        // https://github.com/kissyteam/kissy/issues/67\n\n        if (!tmp && doesNotHasById || tmp && getAttr(tmp, 'id') !== id) {\n          var tmps = util.getElementsByTagName('*', context),\n              tmpLen = tmps.length,\n              tmpI = 0;\n\n          for (; tmpI < tmpLen; tmpI++) {\n            tmp = tmps[tmpI];\n\n            if (getAttr(tmp, 'id') === id) {\n              mySeeds = [tmp];\n              break;\n            }\n          }\n\n          if (tmpI === tmpLen) {\n            mySeeds = [];\n          }\n        } else {\n          if (contextInDom && tmp && context !== contextDocument) {\n            tmp = util.contains(context, tmp) ? tmp : null;\n          }\n\n          mySeeds = tmp ? [tmp] : [];\n        }\n      } else {\n        mySeeds = util.getElementsByTagName(group.value || '*', context);\n      }\n    }\n\n    seedsIndex = 0;\n    seedsLen = mySeeds.length;\n\n    if (!seedsLen) {\n      continue;\n    }\n\n    for (; seedsIndex < seedsLen; seedsIndex++) {\n      var seed = mySeeds[seedsIndex];\n      var matchHead = findFixedMatchFromHead(seed, group);\n\n      if (matchHead === true) {\n        ret.push(seed);\n      } else if (matchHead) {\n        if (matchSub(matchHead.el, matchHead.match)) {\n          ret.push(seed);\n        }\n      }\n    }\n  }\n\n  if (groupLen > 1) {\n    ret = util.unique(ret);\n  }\n\n  return ret;\n}\n\nmodule.exports = select;\n\nselect.parse = function (str) {\n  return parser.parse(str);\n};\n\nselect.matches = matches;\nselect.util = util;\nselect.version = '@VERSION@';\n/**\n * @ignore\n * note 2013-03-28\n *  - use recursive call to replace backtracking algorithm\n *\n * refer\n *  - http://www.w3.org/TR/selectors/\n *  - http://www.impressivewebs.com/browser-support-css3-selectors/\n *  - http://blogs.msdn.com/ie/archive/2010/05/13/the-css-corner-css3-selectors.aspx\n *  - http://sizzlejs.com/\n */","map":{"version":3,"sources":["C:/Users/dofla/Desktop/Stage/propaganda/node_modules/query-selector/lib/query-selector.js"],"names":["util","require","parser","EXPANDO_SELECTOR_KEY","caches","isContextXML","uuid","subMatchesCache","getAttr","el","name","getSimpleAttr","attr","hasSingleClass","isTag","aNPlusB","unescape","unescapeFn","_","escaped","high","isNaN","String","fromCharCode","matchExpr","pseudoFnExpr","param","ab","getAb","a","b","index","parent","parentNode","childNodes","count","child","ret","len","length","nodeType","matchIndexByAb","undefined","elType","tagName","lang","elLang","unEscape","toLowerCase","getAttribute","indexOf","not","negationArg","t","value","pseudoIdentExpr","empty","root","ownerDocument","documentElement","focus","doc","activeElement","hasFocus","type","href","tabIndex","target","hash","location","slice","enabled","disabled","checked","nodeName","selected","attributeExpr","elValue","startsWith","endsWith","relativeExpr","dir","immediate","tag","cls","id","attrib","ident","match","matchFn","pseudo","fn","fnStr","SyntaxError","str","replace","lexer","yy","trim","unEscapeStr","resetStatus","direction","parseInt","eq","isXML","elem","matches","seeds","select","singleMatch","matched","matchSuffix","suffix","matchSuffixLen","matchSuffixIndex","singleMatchSuffix","singleMatchSuffixType","matchImmediate","startEl","relativeOp","startMatch","prev","nextCombinator","findFixedMatchFromHead","head","cur","genId","selectorId","setAttribute","Date","matchSub","matchKey","order","matchSubInternal","matchImmediateRet","context","parse","selector","groupIndex","groupLen","contextDocument","group","document","suffixIndex","suffixLen","seedsIndex","mySeeds","seedsLen","singleSuffix","doesNotHasById","getElementById","contextInDom","contains","tmp","tmps","getElementsByTagName","tmpLen","tmpI","seed","matchHead","push","unique","module","exports","version"],"mappings":"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","sourcesContent":["/**\n * @ignore\n * css3 selector engine for ie6-8\n * @author yiminghe@gmail.com\n */\n\nvar util = require('./query-selector/util');\nvar parser = require('./query-selector/parser');\n\nvar EXPANDO_SELECTOR_KEY = '_ks_data_selector_id_',\n  caches = {},\n  isContextXML,\n  uuid = 0,\n  subMatchesCache = {},\n  getAttr = function (el, name) {\n    if (isContextXML) {\n      return util.getSimpleAttr(el, name);\n    } else {\n      return util.attr(el, name);\n    }\n  },\n  hasSingleClass = util.hasSingleClass,\n  isTag = util.isTag,\n  aNPlusB = /^(([+-]?(?:\\d+)?)?n)?([+-]?\\d+)?$/;\n\n// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\nvar unescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n  unescapeFn = function (_, escaped) {\n    var high = '0x' + escaped - 0x10000;\n    // NaN means non-codepoint\n    return isNaN(high) ?\n      escaped :\n      // BMP codepoint\n      high < 0 ?\n        String.fromCharCode(high + 0x10000) :\n        // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n  };\n\nvar matchExpr;\n\nvar pseudoFnExpr = {\n  'nth-child': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        count = 0,\n        child,\n        ret,\n        len = childNodes.length;\n      for (; count < len; count++) {\n        child = childNodes[count];\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-last-child': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        len = childNodes.length,\n        count = len - 1,\n        child,\n        ret;\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-of-type': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        elType = el.tagName,\n        count = 0,\n        child,\n        ret,\n        len = childNodes.length;\n      for (; count < len; count++) {\n        child = childNodes[count];\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-last-of-type': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        len = childNodes.length,\n        elType = el.tagName,\n        count = len - 1,\n        child,\n        ret;\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  lang: function (el, lang) {\n    var elLang;\n    lang = unEscape(lang.toLowerCase());\n    do {\n      if ((elLang = (isContextXML ?\n        el.getAttribute('xml:lang') || el.getAttribute('lang') :\n          el.lang))) {\n        elLang = elLang.toLowerCase();\n        return elLang === lang || elLang.indexOf(lang + '-') === 0;\n      }\n    } while ((el = el.parentNode) && el.nodeType === 1);\n    return false;\n  },\n  not: function (el, negationArg) {\n    return !matchExpr[negationArg.t](el, negationArg.value);\n  }\n};\n\nvar pseudoIdentExpr = {\n  empty: function (el) {\n    var childNodes = el.childNodes,\n      index = 0,\n      len = childNodes.length - 1,\n      child,\n      nodeType;\n    for (; index < len; index++) {\n      child = childNodes[index];\n      nodeType = child.nodeType;\n      // only element nodes and content nodes\n      // (such as Dom [Dom-LEVEL-3-CORE] text nodes,\n      // CDATA nodes, and entity references\n      if (nodeType === 1 || nodeType === 3 || nodeType === 4 || nodeType === 5) {\n        return 0;\n      }\n    }\n    return 1;\n  },\n  root: function (el) {\n    if (el.nodeType === 9) {\n      return true;\n    }\n    return el.ownerDocument &&\n      el === el.ownerDocument.documentElement;\n  },\n  'first-child': function (el) {\n    return pseudoFnExpr['nth-child'](el, 1);\n  },\n  'last-child': function (el) {\n    return pseudoFnExpr['nth-last-child'](el, 1);\n  },\n  'first-of-type': function (el) {\n    return pseudoFnExpr['nth-of-type'](el, 1);\n  },\n  'last-of-type': function (el) {\n    return pseudoFnExpr['nth-last-of-type'](el, 1);\n  },\n  'only-child': function (el) {\n    return pseudoIdentExpr['first-child'](el) &&\n      pseudoIdentExpr['last-child'](el);\n  },\n  'only-of-type': function (el) {\n    return pseudoIdentExpr['first-of-type'](el) &&\n      pseudoIdentExpr['last-of-type'](el);\n  },\n  focus: function (el) {\n    var doc = el.ownerDocument;\n    return doc && el === doc.activeElement &&\n      (!doc.hasFocus || doc.hasFocus()) && !!(el.type || el.href || el.tabIndex >= 0);\n  },\n  target: function (el) {\n    var hash = location.hash;\n    return hash && hash.slice(1) === getAttr(el, 'id');\n  },\n  enabled: function (el) {\n    return !el.disabled;\n  },\n  disabled: function (el) {\n    return el.disabled;\n  },\n  checked: function (el) {\n    var nodeName = el.nodeName.toLowerCase();\n    return (nodeName === 'input' && el.checked) ||\n      (nodeName === 'option' && el.selected);\n  }\n};\n\nvar attributeExpr = {\n  '~=': function (elValue, value) {\n    if (!value || value.indexOf(' ') > -1) {\n      return 0;\n    }\n    return (' ' + elValue + ' ').indexOf(' ' + value + ' ') !== -1;\n  },\n  '|=': function (elValue, value) {\n    return (' ' + elValue).indexOf(' ' + value + '-') !== -1;\n  },\n  '^=': function (elValue, value) {\n    return value && util.startsWith(elValue, value);\n  },\n  '$=': function (elValue, value) {\n    return value && util.endsWith(elValue, value);\n  },\n  '*=': function (elValue, value) {\n    return value && elValue.indexOf(value) !== -1;\n  },\n  '=': function (elValue, value) {\n    return elValue === value;\n  }\n};\n\nvar relativeExpr = {\n  '>': {\n    dir: 'parentNode',\n    immediate: 1\n  },\n  ' ': {\n    dir: 'parentNode'\n  },\n  '+': {\n    dir: 'previousSibling',\n    immediate: 1\n  },\n  '~': {\n    dir: 'previousSibling'\n  }\n};\n\nmatchExpr = {\n  tag: isTag,\n  cls: hasSingleClass,\n  id: function (el, value) {\n    return getAttr(el, 'id') === value;\n  },\n  attrib: function (el, value) {\n    var name = value.ident;\n    if (!isContextXML) {\n      name = name.toLowerCase();\n    }\n    var elValue = getAttr(el, name);\n    var match = value.match;\n    if (!match && elValue !== undefined) {\n      return 1;\n    } else if (match) {\n      if (elValue === undefined) {\n        return 0;\n      }\n      var matchFn = attributeExpr[match];\n      if (matchFn) {\n        return matchFn(elValue + '', value.value + '');\n      }\n    }\n    return 0;\n  },\n  pseudo: function (el, value) {\n    var fn, fnStr, ident;\n    if ((fnStr = value.fn)) {\n      if (!(fn = pseudoFnExpr[fnStr])) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + fnStr);\n      }\n      return fn(el, value.param);\n    }\n    if ((ident = value.ident)) {\n      if (!pseudoIdentExpr[ident]) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + ident);\n      }\n      return pseudoIdentExpr[ident](el);\n    }\n    return 0;\n  }\n};\n\nfunction unEscape(str) {\n  return str.replace(unescape, unescapeFn);\n}\n\nparser.lexer.yy = {\n  trim: util.trim,\n  unEscape: unEscape,\n  unEscapeStr: function (str) {\n    return this.unEscape(str.slice(1, -1));\n  }\n};\n\nfunction resetStatus() {\n  subMatchesCache = {};\n}\n\nfunction dir(el, direction) {\n  do {\n    el = el[direction];\n  } while (el && el.nodeType !== 1);\n  return el;\n}\n\nfunction getAb(param) {\n  var a = 0,\n    match,\n    b = 0;\n  if (typeof param === 'number') {\n    b = param;\n  } else if (param === 'odd') {\n    a = 2;\n    b = 1;\n  } else if (param === 'even') {\n    a = 2;\n    b = 0;\n  } else if ((match = param.replace(/\\s/g, '').match(aNPlusB))) {\n    if (match[1]) {\n      a = parseInt(match[2], 10);\n      if (isNaN(a)) {\n        if (match[2] === '-') {\n          a = -1;\n        } else {\n          a = 1;\n        }\n      }\n    } else {\n      a = 0;\n    }\n    b = parseInt(match[3], 10) || 0;\n  }\n  return {\n    a: a,\n    b: b\n  };\n}\n\nfunction matchIndexByAb(index, a, b, eq) {\n  if (a === 0) {\n    if (index === b) {\n      return eq;\n    }\n  } else {\n    if ((index - b) / a >= 0 && (index - b) % a === 0 && eq) {\n      return 1;\n    }\n  }\n  return undefined;\n}\n\nfunction isXML(elem) {\n  var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n  return documentElement ? documentElement.nodeName.toLowerCase() !== 'html' : false;\n}\n\nfunction matches(str, seeds) {\n  return select(str, null, seeds);\n}\n\nfunction singleMatch(el, match) {\n  if (!match) {\n    return true;\n  }\n  if (!el) {\n    return false;\n  }\n\n  if (el.nodeType === 9) {\n    return false;\n  }\n\n  var matched = 1,\n    matchSuffix = match.suffix,\n    matchSuffixLen,\n    matchSuffixIndex;\n\n  if (match.t === 'tag') {\n    matched &= matchExpr.tag(el, match.value);\n  }\n\n  if (matched && matchSuffix) {\n    matchSuffixLen = matchSuffix.length;\n    matchSuffixIndex = 0;\n    for (; matched && matchSuffixIndex < matchSuffixLen; matchSuffixIndex++) {\n      var singleMatchSuffix = matchSuffix[matchSuffixIndex],\n        singleMatchSuffixType = singleMatchSuffix.t;\n      if (matchExpr[singleMatchSuffixType]) {\n        matched &= matchExpr[singleMatchSuffixType](el, singleMatchSuffix.value);\n      }\n    }\n  }\n\n  return matched;\n}\n\n// match by adjacent immediate single selector match\nfunction matchImmediate(el, match) {\n  var matched = 1,\n    startEl = el,\n    relativeOp,\n    startMatch = match;\n\n  do {\n    matched &= singleMatch(el, match);\n    if (matched) {\n      // advance\n      match = match && match.prev;\n      if (!match) {\n        return true;\n      }\n      relativeOp = relativeExpr[match.nextCombinator];\n      el = dir(el, relativeOp.dir);\n      if (!relativeOp.immediate) {\n        return {\n          // advance for non-immediate\n          el: el,\n          match: match\n        };\n      }\n    } else {\n      relativeOp = relativeExpr[match.nextCombinator];\n      if (relativeOp.immediate) {\n        // retreat but advance startEl\n        return {\n          el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n          match: startMatch\n        };\n      } else {\n        // advance (before immediate match + jump unmatched)\n        return {\n          el: el && dir(el, relativeOp.dir),\n          match: match\n        };\n      }\n    }\n  } while (el);\n\n  // only occur when match immediate\n  return {\n    el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n    match: startMatch\n  };\n}\n\n// find fixed part, fixed with seeds\nfunction findFixedMatchFromHead(el, head) {\n  var relativeOp,\n    cur = head;\n\n  do {\n    if (!singleMatch(el, cur)) {\n      return null;\n    }\n    cur = cur.prev;\n    if (!cur) {\n      return true;\n    }\n    relativeOp = relativeExpr[cur.nextCombinator];\n    el = dir(el, relativeOp.dir);\n  } while (el && relativeOp.immediate);\n  if (!el) {\n    return null;\n  }\n  return {\n    el: el,\n    match: cur\n  };\n}\n\nfunction genId(el) {\n  var selectorId;\n\n  if (isContextXML) {\n    if (!(selectorId = el.getAttribute(EXPANDO_SELECTOR_KEY))) {\n      el.setAttribute(EXPANDO_SELECTOR_KEY, selectorId = (+new Date() + '_' + (++uuid)));\n    }\n  } else {\n    if (!(selectorId = el[EXPANDO_SELECTOR_KEY])) {\n      selectorId = el[EXPANDO_SELECTOR_KEY] = (+new Date()) + '_' + (++uuid);\n    }\n  }\n\n  return selectorId;\n}\n\nfunction matchSub(el, match) {\n  var selectorId = genId(el),\n    matchKey;\n  matchKey = selectorId + '_' + (match.order || 0);\n  if (matchKey in subMatchesCache) {\n    return subMatchesCache[matchKey];\n  }\n  subMatchesCache[matchKey] = matchSubInternal(el, match);\n  return subMatchesCache[matchKey];\n}\n\n// recursive match by sub selector string from right to left\n// grouped by immediate selectors\nfunction matchSubInternal(el, match) {\n  var matchImmediateRet = matchImmediate(el, match);\n  if (matchImmediateRet === true) {\n    return true;\n  } else {\n    el = matchImmediateRet.el;\n    match = matchImmediateRet.match;\n    while (el) {\n      if (matchSub(el, match)) {\n        return true;\n      }\n      el = dir(el, relativeExpr[match.nextCombinator].dir);\n    }\n    return false;\n  }\n}\n\nfunction select(str, context, seeds) {\n  if (!caches[str]) {\n    caches[str] = parser.parse(str);\n  }\n\n  var selector = caches[str],\n    groupIndex = 0,\n    groupLen = selector.length,\n    contextDocument,\n    group,\n    ret = [];\n\n  if (seeds) {\n    context = context || seeds[0].ownerDocument;\n  }\n\n  contextDocument = context && context.ownerDocument || typeof document !== 'undefined' && document;\n\n  if (context && context.nodeType === 9 && !contextDocument) {\n    contextDocument = context;\n  }\n\n  context = context || contextDocument;\n\n  isContextXML = isXML(context);\n\n  for (; groupIndex < groupLen; groupIndex++) {\n    resetStatus();\n\n    group = selector[groupIndex];\n\n    var suffix = group.suffix,\n      suffixIndex,\n      suffixLen,\n      seedsIndex,\n      mySeeds = seeds,\n      seedsLen,\n      id = null;\n\n    if (!mySeeds) {\n      if (suffix && !isContextXML) {\n        suffixIndex = 0;\n        suffixLen = suffix.length;\n        for (; suffixIndex < suffixLen; suffixIndex++) {\n          var singleSuffix = suffix[suffixIndex];\n          if (singleSuffix.t === 'id') {\n            id = singleSuffix.value;\n            break;\n          }\n        }\n      }\n\n      if (id) {\n        // http://yiminghe.github.io/lab/playground/fragment-selector/selector.html\n        var doesNotHasById = !context.getElementById,\n          contextInDom = util.contains(contextDocument, context),\n          tmp = doesNotHasById ? (\n            contextInDom ?\n              contextDocument.getElementById(id) :\n              null\n          ) : context.getElementById(id);\n        // id bug\n        // https://github.com/kissyteam/kissy/issues/67\n        if (!tmp && doesNotHasById || tmp && getAttr(tmp, 'id') !== id) {\n          var tmps = util.getElementsByTagName('*', context),\n            tmpLen = tmps.length,\n            tmpI = 0;\n          for (; tmpI < tmpLen; tmpI++) {\n            tmp = tmps[tmpI];\n            if (getAttr(tmp, 'id') === id) {\n              mySeeds = [tmp];\n              break;\n            }\n          }\n          if (tmpI === tmpLen) {\n            mySeeds = [];\n          }\n        } else {\n          if (contextInDom && tmp && context !== contextDocument) {\n            tmp = util.contains(context, tmp) ? tmp : null;\n          }\n          mySeeds = tmp ? [tmp] : [];\n        }\n      } else {\n        mySeeds = util.getElementsByTagName(group.value || '*', context);\n      }\n    }\n\n    seedsIndex = 0;\n    seedsLen = mySeeds.length;\n\n    if (!seedsLen) {\n      continue;\n    }\n\n    for (; seedsIndex < seedsLen; seedsIndex++) {\n      var seed = mySeeds[seedsIndex];\n      var matchHead = findFixedMatchFromHead(seed, group);\n      if (matchHead === true) {\n        ret.push(seed);\n      } else if (matchHead) {\n        if (matchSub(matchHead.el, matchHead.match)) {\n          ret.push(seed);\n        }\n      }\n    }\n  }\n\n  if (groupLen > 1) {\n    ret = util.unique(ret);\n  }\n\n  return ret;\n}\n\nmodule.exports = select;\n\nselect.parse = function (str) {\n  return parser.parse(str);\n};\n\nselect.matches = matches;\n\nselect.util = util;\n\nselect.version = '@VERSION@';\n/**\n * @ignore\n * note 2013-03-28\n *  - use recursive call to replace backtracking algorithm\n *\n * refer\n *  - http://www.w3.org/TR/selectors/\n *  - http://www.impressivewebs.com/browser-support-css3-selectors/\n *  - http://blogs.msdn.com/ie/archive/2010/05/13/the-css-corner-css3-selectors.aspx\n *  - http://sizzlejs.com/\n */"]},"metadata":{},"sourceType":"script"}